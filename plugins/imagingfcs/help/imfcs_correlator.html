<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=windows-1250">
  <title>Imaging FCS Plugin: Image Correlators</title>
	  <link rel="prev" href="imfcs_usage.html"> 
	  <link rel="next" href="imfcs_dataformats.html"> 
	  <link rel="contents" href="imaging_fcs.html">     
  </head>
  <body>
    $$qf_commondoc_header.start$$  $$qf_commondoc_header.end$$ 
	<a name="#imagecorrelation"><h2>Image Correlation</h2>
	<p>The imFCS plugin also provides a module that calculates auto- and crosscorrelation functions (ACFs, CCFs) from image series. The image series have to be available in one of these formats:
	   <ul>
	     <li>multi-frame <b>TIFF</b> file (with 8- or 16-bit greyscale frames that all have the same size)</li>
		 <li><b>RadHard raw</b> format</li>
	   </ul>
	   The plugin will read in the image series <i>I(x,y,t)</i> (<i>t=0..T-1, x=0..width-1, y=0..height-1</i>) and then calculate the ACFs/CCFs:
	   <ul>
	     <li><b>autocorrelation function <i>g<sub>x,y</sub>(&tau;)</i> (ACF)</b> for every pixel <i>(x,y)</i>
		     <blockquote>
               <img src="./pic/acf_int.png">
             </blockquote>
			 The result is saved in a comma-separated values (CSV) file <tt>basename.<i>autocorrelation.dat</i></tt>, as described <a href="imfcs_dataformats.html#formats_acf">here</a>. The pixels are ordered row-major, i.e. the order is
			   <i>(0,0), (1,0), ...,(width-1,0), (0,1), (1,1), ..., (width-1,1), ..., (width-1, height-1). </i>
			   
		 </li>
	     <li><b>crosscorrelation function <i>g<sub>(x,y)-(x',y')</sub>(&tau;) </i>(CCF)</b> for every pixel <i>(x,y)</i> to its neighbor pixels <i>(x',y')</i>
		     <blockquote>
               <img src="./pic/ccf_int.png">
             </blockquote>
			 Here the neighbors are the four directly neighboring pixels, i.e. <i>(x',y') = (x-1,y); (x+1,y); (x,y-1); (x,y+1)</i> If a neighboring pixel does not exist, the CCF equals 0 for all values of &tau;. The result is saved in a comma-separated values (CSV) file <tt>basename.<i>crosscorrelation.dat</i></tt>, as described <a href="imfcs_dataformats.html#formats_ccf">here</a>. The pixels are ordered row-major, i.e. the order is
			   <i>(0,0), (1,0), ...,(width-1,0), (0,1), (1,1), ..., (width-1,1), ..., (width-1, height-1). </i>
		 </li>
	   </ul>
	   In both cases the averaging operation is defined as:
		 <blockquote>
		   <img src="./pic/avg.png">
		 </blockquote>
	   In addition these properties are also calculated:
       <ul>
	     <li><b>average/overview image:</b> This 16-bit greyscale TIFF image <tt>basename.<i>overview.tif</i></tt> contains a per-pixel average over all frames in the image series. The average values are calculated as floating point numbers and then mapped to the range 0..65535 (the smallest average pixel will be 0 and the largest 65535) before saving it to the file.</li>
	     <li><b>video:</b> This 16-bit greyscale multi-frame TIFF file <tt>basename.<i>video.tif</i></tt> contains a series of images where each image is the average over a given number of frames (parameter <tt>video_frames</tt>) from the image series. The video greyscale range is expanded to 0..65535, by the same method as above, but for the  whole series.</li>
	     <li><b>statistics:</b> The correlator may calculate a set of statistical parameters from the image series. They are saved as a comma-separated values file <tt>basename.<i>statistics.dat</i></tt> of the format:
		    <blockquote><tt>time [seconds], average, stddev, min, max</tt></blockquote>
			Each property is calculated over a range of <tt>statistics_frames</tt> frames and eachpixel therein. The average averages over all pixels in all of these <tt>statistics_frames</tt> frames. 
		 </li>
	     <li><b>evaluation settings:</b> Finally a human (and computer) readable text file <tt>basename.<i>evalsettigs.txt</i></tt> is created. It contains the major settings used for the calculation. It also lists all files created by the evalution. For a detailed description of the file format, see <a href="imfcs_dataformats.html#formats_evalsettings">here</a></li>
	   </ul>	   
	</p>
    <p></p>
	$$qf_commondoc_backtop$$
    <p></p>
    <p></p>
    <p></p>
	
	<a name="#background"><h2>Background Correction</h2>
    <p>This plugin offers several options for the background correction. This is needed, as CCD-camera already ass a certain offset in order to prevent negativ readings. These possibilities are implemented:
	<ul>
	  <li><b>remove fixed offset:</b> subtracts only the given offset value from each pixel grey value</li>
	  <li><b>remove fixed offset and minimum:</b> subtracts the given offset and the minimum grey value over the whole image series from each pixel grey value</li>
	</ul>
	Subtracting this background, improves the visibility of the correlation, But care must be taken to <u>not</u> remove part of the signal itself, as this may change the measured ACF/CCF amplitude and therefore the estimate of particle number.
	</p>
	$$qf_commondoc_backtop$$
    <p></p>
    <p></p>
    <p></p>
	
	
	<a name="#bleach"><h2>Bleaching Correction</h2>
    <p>This plugin offers also a possibility to correct for bleaching of the sample before the correlation. This might help to get rid of artefacts caused by this. Currently these methods are supported:
	<ul>
	  <li><b>cut data into segments:</b> This is the easiest way of reducing bleaching artefacts. Now the correlator cuts the input time series into few pieces of equal size and calculates a correlation function for each of them. The resulting correlation function is then the average over all the segment functions. This methods works, as the influence of bleaching on a shorter segment is smaller than on the whole series.</li>
	  <li><b>subtract average:</b> This option normalizes the overall intensity of each frame to the average intensity of that pixel in the first 100 frames $$math:\langle I(x,y,t)\rangle_{t=0..100}$$:
	  <blockquote>
	    $$math:I(x,y,t)=I(x,y,t)\cdot\frac{\langle I(x,y,t)\rangle_{t=0..100}}{\langle I(x,y,t)\rangle_{x,y}}=I(x,y,t)\cdot\frac{\langle I(x,y,t)\rangle_{t=0..100}}{\overline{I}(t)}$$
	  </blockquote>
	  </li>
	  <li><b>subtract exponential:</b> This method assumes that the intensity of every pixel decays with a mono-exponential function:
	  <blockquote>
	    $$math:I(t)=I_0+A\cdot\exp(-t/\tau_{bleach}) $$
	  </blockquote>
	  It is further assumed that the decay time $$math:\tau_{bleach}$$ of everypixel is the same, so it may be deduced from a fit to the average intensity trace of the whole image series (which can be done in the Data Explorer window!!!). So after fitting $$math:\tau_{bleach}$$ each pixel may be corrected:
	  <blockquote>
	    $$math:I(x,y,t)=I(x,y,t)\cdot\frac{1}{I_0(x,y)+A(x,y)\cdot\exp(-t/\tau_{bleach})}$$
	  </blockquote>
	  Where the offset $$math:I_0(x,y)$$ and the amplitude $$math:A(x,y)$$ are determined for each pixel, using the averages over the first 100 frames $$math:S(x,y)$$ and last 100 frames $$math::E(x,y)$$:
	  <blockquote>
	    $$math:A(x,y)=\frac{E(x,y)-S(x,y)}{\exp(-T/\tau_{bleach})-1}$$<br>
	    $$math:I_0(x,y)=S(x,y)-A(x,y)$$
	  </blockquote>
	  where <i>T</i> is the overall number of frames.
	  
	  </li>
	</ul>
	Subtracting this background, improves the visibility of the correlation, But care must be taken to <u>not</u> remove part of the signal itself, as this may change the measured ACF/CCF amplitude and therefore the estimate of particle number.
	</p>
	$$qf_commondoc_backtop$$
    <p></p>
    <p></p>
    <p></p>
	
	<a name="#correlators"><h2>Correlators</h2>
	<h3>Correlator Types</h3>
    <p>In the last section only the definition of the ACFs/CCFs was given (in terms of integrals, i.e. continuous imae series). But the image series <i>I(t)</i> (omitting the pixel-specifier) are not continuous, but discrete in time:
	 <blockquote>
	   <img src="./pic/discrete_timeseries.png">
	 </blockquote>	
	 This section will describe the different types of correlators, available in this plugin, that calculate an ACF/CCF from one/two given discrete timeseries <i>I<sub>n</sub></i> (and <i>J<sub>n</sub></i> ). The integration or frame time is specified by <i>&tau;<sub>min</sub></i>:
	<ul>
	  <li><b>Direct Estimation:</b><br>This correlator directly estimates the above given correlation function by replacing the integrals with sums (only the CCF of two signals <i>I<sub>n</sub></i> and <i>J<sub>n</sub></i> is shown, the ACF is given by the CCF of the signal with itself, i.e. <i><i>J<sub>n</sub></i>=<i>I<sub>n</sub></i></i>):
	     <blockquote>
		   <img src="./pic/acf_direct.png">
		 </blockquote>
	  This sum is evaluated for semi-logarithmically spaced lags <i>&tau;</i>. These are specified by three integer numbers <i>S, P</i> and <i>m</i> that result in <i>S&middot;P</i> different values of <i>&tau; = &tau;<sub>s,p</sub></i>:
	     <blockquote><i>
		   &tau;<sub>0,0</sub> = &tau;<sub>min</sub><br>
		   &tau;<sub>s,p</sub> = &tau;<sub>s-1,P-1</sub> + p&middot;m<sup>s</sup>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</i>with<i> s=0..S-1 </i>and</i> p=0..P-1
		 </i></blockquote>
	  This recursive formula leads to <i>S</i> blocks of <i>P</i> linearly spaces lags. The difference between two subsequent lags increases exponentially (<i>m<sup>s</sup></i>) from block to block.
	  The normalization is explained in more detail below.
	  </li>

	  <li><b>Direct Correlation, with Averaging:</b><br>This correlator yields the same results as the <b>Direct Estimation</b>, but intrinsically averages the calculated correlation function (with a triangular kernel, see below). The width of the averaging increases from decade to decade of the quasi-logarithmically spaced &tau;-values at which the correlation function is evaluated. The correlation works like this:
	  <ol>
	    <li>calculate $$math:g(\tau_i)$$ at <i>P</i> linearly spaced lags $$math:\tau_{i}=i$$, using the same estimation as above:
	     <blockquote>
		   <img src="./pic/acf_direct.png">
		 </blockquote>		
		</li>
	    <li>average the input signal series <i>J<sub>n</sub></i> and <i>I<sub>n</sub></i> by summing up <i>m</i> subsequent values. The new series <i>J<sub>n</sub>'</i> and <i>I<sub>n</sub>'</i> will then hold only <i>N/m</i> values.
		</li>
	    <li>return <i>S</i> times to step 1 with the new input signals</li>
	  </ol>
	  This can be illustrated:
	     <blockquote>
		   <img src="./pic/acf_directavg.png">
		 </blockquote>		

	  </li>

	  <li><b>Multi-&tau; Correlator:</b><br>
	  This correlation scheme was introduced by K. Schätzel [1,2] for hardware correlators. It allows to estimate the ACF/CCF without keeping the whole time series in memory. It is based on the above semi-logarithmically spaced values of <i>&tau;<sub>s,p</sub></i>. For each of the <i>P</i> linear blocks an averaged set of input signals is created:
	     <blockquote>
		   <img src="./pic/multitau_signals.png">
		 </blockquote>	  
	  Using this scheme, the estimate of the CCF can be written as above:
	     <blockquote>
		   <img src="./pic/multitau_ccf.png">
		 </blockquote>	  	  
	  As can be seen only the averages intensities <i>I<sub>s,n</sub></i> appear in the formula. This scheme can also be drawn as a schematic, which shows the direct connection to a simple hardware implementation [3]:
	     <blockquote>
		   <img src="./pic/multi_tau_schaematic.png">
		 </blockquote>
      The &Delta;&tau; blocks delay the input signal by &Delta;&tau;, the &times;-blocks multiply the two input signals and the &Sigma;-blocks accumulate the input. The top row (a) shows a fully linear implementation (no logarithmic spacing) and (b)/(c) the multi-&tau; implementation. This plugin contains a software version of this scheme. Using this scheme introduces an additional (triangular) averaging into the ACF/CCF (as compared to the direct estimation), but allows to calculate it without the need to keep the whole image series in memory. Also this averaging depends on the linear block <i>s</i> and has only little impakt for small <i>s</i>. the systematic error introduced increases for the larger lags for which usually measured ACFs/CCFs already decayed to 0 [4]:
	     <blockquote>
		   <img src="./pic/multitau_avg.png">
		 </blockquote>
	  Here <img src="./pic/multitau_avg_triangle.png"> is a triangular kernel function and * denotes the convolution product. 
	  </li>
	</ul>
	
	<h3>Normalization</h3>
	All types of correlators use the same normalization scheme for the term <i>1/&lang;I&rang;&lang;J&rang;</i> in the definition of the ACF/CCF. The normalization scheme is called "symmetric normalization", introduced in [2]. This normalization takes care for the reduced number <i>T-&tau;<sub>s,p</sub></i> of accumulations in the ACF/CCF and is defined as:
	     <blockquote>
		   <img src="./pic/symm_normalization.png">
		 </blockquote>
	The "delayed monitor" <i>M(&tau;<sub>k</sub>)</i> may be estimated in two ways. Either it is calculated for every lag <i>&tau;<sub>k</sub></i> separately, or it can bes estimated as:
		 <blockquote>
		   <img src="./pic/symm_normalization_estimate.png">
		 </blockquote>
	from the zero-lag monitor <i>M(0)</i>. This method possibly introduces additional errors that are but negligible for longer image series (see [3] for a detailed discussion).
	</p>
	<h3>Comparison of the correlators</h3>
	<p>
	  In general the results of all correlation scheme are the same. Those with intrinsic averaging will decrease the noise on the correlation curve at larger lag times, where the statistics tends to get worse due to the fewer summands in the average. This is beneficial, when the correlation curves decay to zero/one in this regime, as then the estimation error is decreased. If the correlation curves do not decay, using a correlator with averaging will introduce an additional systematic error. This can be illustrated in these examples:
	     <blockquote>
		   <b>autocorrelation of a sine signal:</b><br>
		   <img src="./pic/corr_examples_sine.png">
		 </blockquote>		
	     <blockquote>
		   <b>autocorrelation which decays to one for different decay times:</b><br>
		   <img src="./pic/corr_examples.png">
		 </blockquote>	
      In addition to these discussed errors there are other differences in the implementations: The <i>direct correlators</i> need the whole image series to reside in memory, so if your image series is very long (longer than ~1,000,000 frames and with many pixels) it is usually better to use the multi-&tau; correlators, as these are fed frame by frame, so only few frames reside in memory at every time. 
    </p>
	
    <p><b>References:</b><blockquote>
	  [1]: K. Sch&auml;tzel (1985): <b>New concepts in correlator design</b>, <i>Institute of Physics Conference Series</i> <b>77</b>, 175-184.<br>
	  [2]: K. Sch&auml;tzel (1990): <b>Noise on photon correlation data: I. Autocorrelation functions</b>, <i>Quantum Opt.</i> <b>2</b>, 287-305<br>
	  [3]: J. Buchholz, J.W. Krieger, etal (2011): <b>FPGA implementation of a 32&times;32 autocorrelator array for analysis of fast image series</b>, <i>to be published</i><br>
	  [4]: Z. Kojro, A. Riede, M. Schubert and W. Grill (1999): <b>Systematic and statistical errors in correlation estimators obtained from various digital correlators</b> <i>Review of Scientific Instruments</i> <b>70</b>, 4487-4496<br>
	</blockquote></p>
	$$qf_commondoc_backtop$$
    <p></p>
    <p></p>
    <p></p>
	
	<a name="#usage"><h2>Importing correlated data into a QuickFit project</h2>
    <p>This plugin supplied a simple dialog that allows to set all options, for the evaluation described above. It allows to define several "jobs" and to evaluate these one-by one (also some in parallel on a multi-core machine), as usually the correlation may take several minutes (which allows you to go and drink a short coffee ;-) Note however that correlation usually creates a high load on hard disk access, so you do not always improve the processing speed with more cores, as the bottle-neck is the harddisk access speed.</p>
    <p>First you will have to select a file containing the image series (<b>Image Series</b>):<ul>
	  <li><img src=":/imaging_fcs/fileopen.png"> displays a dialog that allows to selecta file from the hard disk.</li>
	  <li><img src=":/imaging_fcs/use_file.png"> will load an image series entered in the input field by hand.</li>
	<ul></p>
	<p>Subsequently the plugin will read the image series properties and meta-data. Then you can set all the properties (<b>Details:</b>) defining the actions to be taken:
	<ul>
	    <li>All the output files start with the same <tt>basename</tt> in the filenames (see above). This <tt>basename</tt> is created from three parts (let's assume that the input filename is <tt><i>[path_to]/[inputfilename].[ext]</i></tt>):
			<blockquote><tt><i>[path_to]/</i><b>[prefix]</b><i>[inputfilename]</i><b>[postfix]</b><i>[ending]</i></tt></blockquote>
			Here <tt><i>[inputfilename]</i></tt> is the filename without extension of the input file (i.e. <tt>inputfilename</tt>), <tt></i>[ending]</i></tt> is the ending specifying the output file (see above, e.g. <tt>.evalsetting.txt</tt>, <tt>.autocorrelation.dat</tt>, ...). If <tt><i>[prefix]</i></tt> contains directory separators (<tt>/</tt>) the output files will be created in subdirectories. in addition you may use some special strings in <tt><i>[prefix]</i></tt> and <tt><i>[postfix]</i></tt> (case-insensitive):
			<ul>
			  <li><tt>%COUNTER%</tt> will first simply be deleted. If a set of output files with the given name already exist, the counter is increased until no output files with the given name exist.</li>
			  <li><tt>%S%</tt> S parameter of the correlator</li>
			  <li><tt>%P%</tt> P parameter of the correlator</li>
			  <li><tt>%M%</tt> m parameter of the correlator</li>
			  <li><tt>%framerate%</tt> framerate in Herz</li>
			  <li><tt>%frametime%</tt> frametime in microseconds</li>
			  <li><tt>%first%</tt> first used frame</li>
			  <li><tt>%last%</tt> last used frame</li>
			  <li><tt>%backoffset%</tt> offset of background correction</li>
			  <li><tt>%backcorrection%</tt> background correction mode</li>
			  <li><tt>%backcorrectionid%</tt> background correction mode as number</li>
			  <li><tt>%segments%</tt> segments the image series is cut into</li>
			  <li><tt>%correlator%</tt> correlator type used</li>
			  <li><tt>%correlatorid%</tt> correlator type used as number</li>
			</ul>
			As an example if <tt><i>[prefix]</i>="./results/"</tt> and <tt><i>[postfix]</i>="%COUNTER%"</tt>, the these output files will be created:
			<blockquote><tt>[path_to]/results/[inputfilename].autocorrelation.dat<br>[path_to]/results/[inputfilename].crosscorrelation.dat<br>...
			</tt></blockquote>
			If you start a job for the same input file and the same postfox/prefix again, these files will be created:
			<blockquote><tt>[path_to]/results/[inputfilename]<b>1</b>.autocorrelation.dat<br>[path_to]/results/[inputfilename]<b>1</b>.crosscorrelation.dat<br>...
			</tt></blockquote>
		</li>
	    <li>Sometimes one wants to exclude certain parts of the image series. This is possible by setting the <b>first</b> and <b>last frame</b>.</li>
		<li>Sometimes model fitting is more reliable, if an estimate of the statistic error <i>&Delta;g(&tau;)</i> introduced when estimating the ACF/CCF is known. So this module allows to <b>cut the input image series into several segments</b> (taking into account the iven first and last frame) and to correlate each segment separately. Then the ACF/CCF may be calculated as the average and the error as the standard deviation over the ACF/CCF for the single segments.</li>
		<li>It is especially important to set the correct <b>framerate</b> (in images/second) or <b>frame time</b> (=1/framerate in microseconds), as this is crucial for the correctlag time axis.</li> 
		<li>If you want to immediately add the results to the current project, don't forget to check the corresponding box below the parameters.</li> 
		<li>The rest of the settings were already described above.</li>
	</ul></p>
	<p>Finally a click on <b><img src=":/imaging_fcs/add_job.png"> add job</b> will add the job to the list of jobs to be processed (bottom of the window). </p>
    <p>All the processing jobs (threads) are shown as a list in the bottom of the correlator dialog. The status of each job is displayed together with its progress and the overall progress. The current status of each job is shown as an icon:
	<blockquote>
	    <img src=":/imaging_fcs/thread_wait.png"> <b>waiting:</b> The job waits for an empty processing slot.<br>
	    <img src=":/imaging_fcs/thread_run.png"> <b>running:</b> The job is currently processed.<br>
	    <img src=":/imaging_fcs/thread_ok.png"> <b>done:</b> Processing of the job finished successfully.<br>
	    <img src=":/imaging_fcs/thread_error.png"> <b>error: Processing of the job finished with an error. The error is displayed together with the job status.</b>
	</blockquote>
	</p>
    <p>Click <b>Close</b> to close the window. If some jobs are still running, you may either wait until they are finished, or cancel them. All jobs that finished sucessfully and were marked to be added to the project will now be added. It is also possible to add a job later, by simply selecting the <tt>basename.autocorrelation.dat</tt> or <tt>basename.crosscorrelation.dat</tt> files as described <a href="imfcs_usage.html#import">here</a>.</p>
	</body>
</html>






















